# 树状数据的前端呈现策略

## 先验（原则）

本策略在讨论的时候遵守一下原则，即不讨论以下策略的优越性：

- 单向数据流，即强调 prop 时不可变，要求数据本身也具有不可变性。
- 呈现方式支持`tag`和`data`两种模式，但是对两者混用的方式不做讨论。

## 同类树状数据在前端上使用几种呈现方式。

树状数据在节点上具有相似性，这在某种程度上也暗示我们大部分逻辑应该交由一个相似概念完成，但是实际上我们在实际使用过程中，我们通常会从两个不同的方面同时看待一个树：

- 从整体上，它是一颗树，它的兄弟节点都不是树
- 从局部上，它是一个树的根节点

这一认知揭示了，从某种层面上，树的呈现至少会出现 2 类逻辑，即整体性和层级性。其中整体性带来了树区别于其他组件的性质，而层级性象征着树状这一递归结构构成局部上的相似性。故我们可以给出这一结论：

- 有一部分逻辑是作为一个整体性的结构共同发挥作用，在树的结构上，这部分逻辑被认为是树与外界的交互功能载体，位置上多和根节点在一起。
- 有一部分逻辑是服务与节点本身存在，通常意义上这些逻辑由树本身的结构息息相关，他们通常不会与外界交互，仅作为维护内部状态为主。

在讨论根节点的特殊性后，接下来，我想聊一聊树的非根节点。非根节点很自然的可以分为两类：

- 非根非叶节点
- 叶节点

这种区分太过于明确，又有什么好聊的了？实则不然，在日常使用过程中，用户对非叶节点与叶节点的感性认知直接决定了在实现过程中相同点和不同点所占用的比例。这可能有点绕口，接下来我们还是基于实例出发。

假设这样一个场景，我们现在有一个部门人员的树状数据，我们先假设有管理人员和员工两类角色。当用户看见这一类数据时，会很自然的认为除了管理人员管理下属之外，管理人员和员工本身并没有太大区别（P.S.这里的区别是相较于后者）,他们都是人类，都有着工资，薪水，入职时间，职称等属性。在这里，我们可以说部门人员的树状数据在展示过程中，相似性多于差异性。

但当我们的需求开始逐渐变得复杂的过程中，我们开始引入部门这一概念，这时候用户在先验知识的加持下，他们会认为部门和员工之间上没有任何相似性，部门和管理人员之间也出了是人员的父节点外看不出其他的相似性。尽管部门的引入在数据结构上波澜不惊，但具体页面的实现上，我们会惊讶的发现这带来了 breaking change！

现在我们重新回顾这一过程，站在管理人员的角度，我们或许可以发现问题的答案。即管理人员与员工的相似性从用户角度出发是源于节点本身的属性，管理人员与部门的相似性（都管理着人员）是源于节点所在树的层级。这两类先验知识对于用户来说是不言自明的。反过来，在具体的数据建模过程中，我们为部门设置类似人员的的属性页面，某种程度上来说则对用户显得不是那么直接。至此，我们可以得出以下结论：树节点的功能大致可以分为以下两类：

- 管理子，祖孙节点的能力
- 节点自身的能力

这两类能力的分布多少是区分实际应用过程中非叶节点和叶节点的区别，而决定能力具体分布的往往是具体的业务场景，有些时候，树的层级关系只是用来展示的需求，这个时候非叶节点和叶节点之间可能不存在区分。而与之相反，在某些场景中，又格外强调层级关系的管理能力，这个时候，非叶节点就变得尤为关键。

### 结论

综上，在充分讨论实际使用场景后，我们知道在设计树节点功能的时候，有三个方向的功能值得我们去讨论：

- 树作为整体的功能（这往往由根节点或根节点的父节点所持有）
- 非叶节点的管理功能
- 节点自身用来表述自身的能力
